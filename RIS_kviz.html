<!doctype html>
<html lang="sl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>XML / REST / JSON Kviz</title>
<style>
body { font-family: system-ui; background:#0f172a; color:white; margin:0; }
.wrap { max-width:900px; margin:auto; padding:30px; }
.card { background:#1e293b; padding:25px; border-radius:12px; }
button { padding:10px 18px; margin-top:15px; border-radius:8px; border:none; cursor:pointer; }
.primary { background:#3b82f6; color:white; }
.secondary { background:#475569; color:white; margin-right:8px; }
.restart { background:#10b981; color:white; margin-left:8px; }
.result { background:#111827; padding:20px; border-radius:10px; margin-top:20px; }
.option { margin:6px 0; }
.correct { color:#22c55e; }
.wrong { color:#ef4444; }
hr { border:1px solid #334155; }
small { color:#cbd5e1; }

/* --- REVIEW UI (kot na tvoji sliki) --- */
.panel { background:#0b1224; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:16px; }
.row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
.space { height:14px; }
.pill { display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; font-size:13px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.04); }
.pill.good { border-color: rgba(34,197,94,.35); }
.pill.bad { border-color: rgba(239,68,68,.35); }
.pill.warn { border-color: rgba(245,158,11,.35); }
.h2 { font-size:20px; margin:0 0 6px 0; }
.muted { color:#cbd5e1; font-size:13px; }
.qcard { background:#0b1224; border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:16px; margin-top:14px; }
.qhead { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
.qtitle { font-weight:700; }
.qscore { font-weight:700; }
.bullets { margin:10px 0 0 0; padding-left:18px; }
.bullets li { margin:6px 0; }
.li-ok { color:#22c55e; }
.li-bad { color:#ef4444; }
.li-miss { color:#f59e0b; }
.btnbar { display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; }
.btn { padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:white; cursor:pointer; }
.btn.primary { background:#3b82f6; border-color: rgba(59,130,246,.35); }
.btn.ghost { background:transparent; }
.divider { height:1px; background:rgba(255,255,255,.08); margin:14px 0; }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" id="quiz"></div>
</div>

<script>
const questions = [

/* =========================
BOOLEAN (1‚Äì24)
========================= */

{type:"boolean",question:"≈†ifriranje XML dokumentov zagotavlja ≈°ifriranje podatkov od zaƒçetka do konca (end-to-end).",answer:false},
{type:"boolean",question:"Vrednost atributa XML elementa mora biti zapisana v narekovajih.",answer:true},
{type:"boolean",question:"Uporaba kategorije elementa ANY v DTD doloƒça odprti del dokumenta, nad katerim nimamo nadzora.",answer:true},
{type:"boolean",question:"XML spada v skupino oznaƒçevalnih jezikov SGML.",answer:true},
{type:"boolean",question:"V XML dokumentih je privzeto definirana in rezervirana oznaka imenskega prostora xmlns.",answer:true},
{type:"boolean",question:"XPath je sintaksa za definiranje delov XML dokumenta.",answer:true},
{type:"boolean",question:"Nekatere mo≈ænosti DTD besednjakov predstavljajo varnostno tveganje.",answer:true},
{type:"boolean",question:"Ime vsakega sestavljenega tipa v XML besednjaku po dogovoru konƒçamo z besedo 'Type'.",answer:true},
{type:"boolean",question:"SOAP storitve po Richardsonovem modelu zrelosti spadajo v raven 0.",answer:true},
{type:"boolean",question:"RDF je ogrodje za doloƒçanje povezav med razredi.",answer:true},
{type:"boolean",question:"Pri poimenovanju XML elementov se izogibamo uporabi pike, dvopiƒçja in znaka minus.",answer:false},
{type:"boolean",question:"Ovit (Enveloped) XML elektronski podpis je povezan s podatki, ki jih podpisuje.",answer:true},
{type:"boolean",question:"Pri uporabi REST storitev lahko dostopamo neposredno do informacijskega vira.",answer:true},
{type:"boolean",question:"Ime XML besednjaka mora biti enako imenu imenskega prostora.",answer:false},
{type:"boolean",question:"SOAP pomeni RESTful Transfer.",answer:false},
{type:"boolean",question:"Pri uporabi Web API podatke praviloma prena≈°amo z uporabo ovojnice SOAP.",answer:false},
{type:"boolean",question:"Za zapise s stalno dol≈æino je znaƒçilno, da je dol≈æina vsake vrstice lahko enaka.",answer:true},
{type:"boolean",question:"Imenski prostor XML elementa mora biti URI.",answer:true},
{type:"boolean",question:"XML dokumentov ne moremo prikazati samo z uporabo CSS.",answer:false},
{type:"boolean",question:"Podpora za XSLT transformacijo je vgrajena v spletne brskalnike.",answer:true},
{type:"boolean",question:"Znak + v DTD doloƒça element z niƒç ali veƒç otroki.",answer:false},
{type:"boolean",question:"JSON-LD pomeni Long Data.",answer:false},
{type:"boolean",question:"JSON-LD je poenostavljen zapis za kratko zapisovanje JSON podatkov.",answer:false},
{type:"boolean",question:"Razred XmlWriter shrani celoten dokument v pomnilnik.",answer:false},

/* =========================
MULTI (25‚Äì43)
========================= */

{
type:"multi",
question:"Oznaƒçite razlike med XML atributi in XML elementi:",
options:[
"Z atributi praviloma zapi≈°emo podatke namenjene stroju",
"Atribute je mo≈æno enostavno raz≈°iriti",
"Atributi lahko vsebujejo veƒç vrednosti",
"Atributi lahko vsebujejo drevesno strukturo",
"Atributi so bolj berljivi kot elementi",
"Podatki v atributih porabijo veƒç prostora"
],
answer:[0]
},

{
type:"multi",
question:"Kateri so standardi za zapis XML besednjakov?",
options:["DTD","XML Schema","JSON-LD","JSON","XSLT","XSL-FO"],
answer:[0,1]
},
{
type:"multi",
question:"Oznaƒçite pravilno zapisane DTD definicije:",
options:[
"<!ELEMENT knjiga (naslov, avtor)*>",
"<!ELEMENT knjiga (naslov,avtor)>",
"<!ELEMENT knjiga (naslov|avtor|id)>",
"<!ELEMENT knjiga [naslov,avtor]>",
"<!ELEMENT knjiga (naslov,avtor|id)>",
"<!ELEMENT knjiga (naslov,avtor)*>"
],
answer:[1,2]
},

{
type:"multi",
question:"Kateri podatkovni tipi niso doloƒçeni z XML Schema?",
options:["char","null","color","float","date","boolean"],
answer:[0,1,2]
},

{
type:"multi",
question:"Katero doloƒçilo zdru≈æi zaporedje veƒç presledkov v enega?",
options:["collapse","replace","preserve","change","tabulize","whitespace"],
answer:[0]
},

{
type:"multi",
question:"Kompleksni elementi v XML:",
options:[
"Lahko so prazni",
"Vsebujejo samo druge elemente",
"Vsebujejo samo podatke",
"Vsebujejo druge elemente in podatke",
"Vsebujejo besednjake",
"Vsebujejo transformacije"
],
answer:[0,1,2,3]
},

{
type:"multi",
question:"Operator za izbiro star≈°a vozli≈°ƒça:",
options:["..",".","::","/","@","//"],
answer:[0]
},

{
type:"multi",
question:"Namen REST storitev:",
options:[
"Hrambo XML dokumentov",
"Povezovanju aplikacijskih sistemov",
"Prikazovanju XML podatkov",
"Izdelavi HTML dokumentov",
"Komunikaciji sistem‚Äìsistem",
"Komunikaciji ƒçlovek‚Äìstroj"
],
answer:[1,4]
},

{
type:"multi",
question:"XPath izrazi brez predikata:",
options:[
"/univerza/fakulteta[1]",
"/univerza/fakulteta[last()]",
"/univerza[@id]",
"//id",
"/univerza/fakulteta",
"node()"
],
answer:[3,4,5]
},

{
type:"multi",
question:"Znaƒçilnosti XmlDocument in XPathDocument:",
options:[
"XmlDocument omogoƒça spreminjanje vsebine dokumenta",
"XmlDocument omogoƒça uporabo XPath izrazov",
"XPathDocument omogoƒça uporabo XPath izrazov"
],
answer:[0,1,2]
},

{
type:"multi",
question:"Tehnologije za izdelavo PDF iz XML:",
options:["HTML","CSS","DTD","JavaScript","XSL-FO","XSL"],
answer:[4,5]
},

{
type:"multi",
question:"SSL zagotavlja:",
options:[
"PKI",
"Od zaƒçetka do konca",
"Od konca do zaƒçetka",
"Popolno ≈°ifriranje",
"Stre≈æni≈°ko ≈°ifriranje",
"Od toƒçke do toƒçke"
],
answer:[5]
},

{
type:"multi",
question:"Raven REST po Richardsonu (veƒç URI + GET):",
options:["Raven 0","Raven 1","Raven 2","Raven 3"],
answer:[1]
},

{
type:"multi",
question:"Znaƒçilnosti HTTP GET:",
options:[
"Zahteva ne rabi imeti telesa",
"Zahteva mora imeti telo",
"Se ne more uporabljati za prenos veƒçje koliƒçine podatkov",
"Preneseni podatki so vidni v dnevniku"
],
answer:[0,2,3]
},

{
type:"multi",
question:"Razlika med posrednikom sporoƒçil in vrsto:",
options:[
"Zna pretvarjati med formati",
"Ne zagotavlja asinhrone komunikacije",
"Ima podporo za zanesljivo dostavo",
"Obdela, poenostavi in stisne sporoƒçila",
"Zagotavlja SOA",
"Ima podporo za brskalnike"
],
answer:[0,2]
},

{
type:"multi",
question:"Standard za izdelavo SOAP storitev:",
options:["WSDL","JavaScript","DOM","HTML","JSON","CSS"],
answer:[0]
},

{
type:"multi",
question:"Pristopi za izdelavo JSON besednjakov:",
options:[
"Napi≈°emo JSON besednjak",
"Uporabimo knji≈ænico in generiramo iz modela",
"Pretvorimo JSON dokument",
"Napi≈°emo XML besednjak",
"Ustvarimo iz REST storitve",
"GraphQL"
],
answer:[0,1]
},

{
type:"multi",
question:"Najhitrej≈°a komunikacijska tehnologija:",
options:["gRPC","REST","JSON-RPC","GraphQL","Thrift","SOAP"],
answer:[0]
}

];

let current = 0;
let userAnswers = new Array(questions.length).fill(null);

function render(){
  const q = questions[current];
  const div = document.getElementById("quiz");

  div.innerHTML = `
    <h2>Vpra≈°anje ${current+1} / ${questions.length}</h2>
    <p>${q.question}</p>
    <div id="options"></div>
    <div>
      <button class="secondary" onclick="prev()">Nazaj</button>
      <button class="primary" onclick="next()">Naprej</button>
    </div>
  `;

  const optDiv = document.getElementById("options");

  if(q.type === "boolean"){
    optDiv.innerHTML = `
      <div class="option"><label><input type="radio" name="ans" value="true"> DA</label></div>
      <div class="option"><label><input type="radio" name="ans" value="false"> NE</label></div>
    `;
  } else {
    q.options.forEach((opt,i)=>{
      optDiv.innerHTML += `<div class="option"><label><input type="checkbox" value="${i}"> ${opt}</label></div>`;
    });
  }

  restoreSaved();
}

function saveCurrent(){
  const q = questions[current];

  if(q.type === "boolean"){
    const s = document.querySelector('input[name="ans"]:checked');
    userAnswers[current] = s ? s.value : null;
  } else {
    const checked = [...document.querySelectorAll('input[type="checkbox"]:checked')]
      .map(c=>parseInt(c.value));
    userAnswers[current] = checked;
  }
}

function restoreSaved(){
  const q = questions[current];
  const saved = userAnswers[current];
  if(saved === null) return;

  if(q.type === "boolean"){
    const el = document.querySelector(`input[name="ans"][value="${saved}"]`);
    if(el) el.checked = true;
  } else {
    (saved || []).forEach(i=>{
      const el = document.querySelector(`input[type="checkbox"][value="${i}"]`);
      if(el) el.checked = true;
    });
  }
}

function next(){
  saveCurrent();
  if(current < questions.length - 1){
    current++;
    render();
  } else {
    showResult();
  }
}

function prev(){
  saveCurrent();
  if(current > 0){
    current--;
    render();
  }
}

/* ---------- REVIEW helperji ---------- */

function multiStats(q, ans){
  const correctSet = new Set(q.answer);
  const userSet = new Set((ans || []));

  let correctPicked = 0;
  let wrongPicked = 0;
  let missing = 0;

  for(const u of userSet){
    if(correctSet.has(u)) correctPicked++;
    else wrongPicked++;
  }
  for(const c of correctSet){
    if(!userSet.has(c)) missing++;
  }

  const exact = (wrongPicked === 0 && missing === 0 && correctPicked === correctSet.size);

  let points = 0;
  if(exact) points = 1;
  else if(wrongPicked === 0 && correctPicked > 0) points = 0.5;
  else points = 0;

  return { correctPicked, wrongPicked, missing, points };
}

function boolPoints(q, ans){
  if(ans === null) return { points: 0, ok:false };
  const ok = ((ans === "true") === q.answer);
  return { points: ok ? 1 : 0, ok };
}

/* ---------- RESULT page ---------- */

function showResult(){
  saveCurrent();
  const div = document.getElementById("quiz");

  let totalPoints = 0;
  let lostQuestions = 0;

  let totalCorrectPicked = 0;
  let totalWrongPicked = 0;
  let totalMissing = 0;

  const review = [];

  questions.forEach((q, i) => {
    const ans = userAnswers[i];

    if(q.type === "boolean"){
      const r = boolPoints(q, ans);
      totalPoints += r.points;
      if(r.points < 1) lostQuestions++;
      review.push({ index:i, q, ans, points:r.points, max:1, kind:"boolean" });
    } else {
      const s = multiStats(q, ans);
      totalPoints += s.points;
      if(s.points < 1) lostQuestions++;

      totalCorrectPicked += s.correctPicked;
      totalWrongPicked += s.wrongPicked;
      totalMissing += s.missing;

      review.push({ index:i, q, ans, points:s.points, max:1, kind:"multi", stats:s });
    }
  });

  div.innerHTML = `
    <div class="panel">
      <div class="h2">Povzetek</div>
      <div class="muted">Rezultat: ${totalPoints.toFixed(2)} / ${questions.length} (${((totalPoints/questions.length)*100).toFixed(1)}%)</div>
      <div class="space"></div>
      <div class="row">
        <span class="pill good">‚úÖ pravilno izbranih: <b>${totalCorrectPicked}</b></span>
        <span class="pill bad">‚ùå napaƒçno izbranih: <b>${totalWrongPicked}</b></span>
        <span class="pill warn">‚ö†Ô∏è manjkajoƒçih pravilnih: <b>${totalMissing}</b></span>
        <span class="pill">üßæ Vpra≈°anja z izgubo toƒçk: <b>${lostQuestions}</b></span>
      </div>

      <div class="btnbar">
        <button class="btn primary" onclick="restartQuiz()">Zaƒçni znova (vsa)</button>
        <button class="btn" onclick="goBackToQuestions()">Nazaj na vpra≈°anja</button>
      </div>
    </div>

    <div class="divider"></div>
    <div class="h2">Pregled napak</div>
  `;

  const mistakes = review.filter(r => r.points < 1);

  if(mistakes.length === 0){
    div.innerHTML += `<div class="qcard"><b>Ni napak</b> ‚Äî vse je pravilno.</div>`;
    return;
  }

  mistakes.forEach(r => {
    const q = r.q;

    div.innerHTML += `<div class="qcard">
      <div class="qhead">
        <div class="qtitle">#${r.index+1} ${q.question}</div>
        <div class="qscore">${r.points.toFixed(2)}/${r.max.toFixed(2)}</div>
      </div>
    `;

    if(r.kind === "boolean"){
      const userText = r.ans === null ? "Brez odgovora" : (r.ans === "true" ? "DA" : "NE");
      const corrText = q.answer ? "DA" : "NE";
      const ok = (r.points === 1);

      div.innerHTML += `
        <div class="space"></div>
        <span class="pill ${ok ? "good" : "bad"}">${ok ? "‚úÖ Tvoj odgovor:" : "‚ùå Tvoj odgovor:"} <b>${userText}</b></span>
        <span class="pill good">‚úÖ Pravilno: <b>${corrText}</b></span>
      </div>`;
      return;
    }

    const userSet = new Set(r.ans || []);
    const correctSet = new Set(q.answer);

    div.innerHTML += `
      <div class="space"></div>
      <div class="row">
        <span class="pill good">‚úÖ pravilno oznaƒçeno: <b>${r.stats.correctPicked}</b></span>
        <span class="pill bad">‚ùå napaƒçno oznaƒçeno: <b>${r.stats.wrongPicked}</b></span>
        <span class="pill warn">‚ö†Ô∏è manjkajoƒçe pravilno: <b>${r.stats.missing}</b></span>
      </div>

      <ul class="bullets">
    `;

    q.options.forEach((opt, idx) => {
      const isCorrect = correctSet.has(idx);
      const picked = userSet.has(idx);

      if(picked && isCorrect){
        div.innerHTML += `<li class="li-ok">‚úÖ ${opt}</li>`;
      } else if(picked && !isCorrect){
        div.innerHTML += `<li class="li-bad">‚ùå ${opt}</li>`;
      } else if(!picked && isCorrect){
        div.innerHTML += `<li class="li-miss">‚ö†Ô∏è ${opt}</li>`;
      } else {
        div.innerHTML += `<li>${opt}</li>`;
      }
    });

    div.innerHTML += `</ul></div>`;
  });
}

function restartQuiz(){
  current = 0;
  userAnswers = new Array(questions.length).fill(null);
  render();
}

function goBackToQuestions(){
  current = 0;
  render();
}

render();
</script>
</body>
</html>
